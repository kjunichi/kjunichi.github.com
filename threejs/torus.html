<html>

<head></head>

<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r42/Three.min.js"></script>
    <script>
        // forked from kjunichi's "こんどはトーラスです" http://jsdo.it/kjunichi/xPVF
        // forked from kjunichi's "Three.jsでローマ曲面を描画した" http://jsdo.it/kjunichi/ocRI
        // forked from kjunichi's "Three.jsでようやくポリゴンの描画が出来た" http://jsdo.it/kjunichi/juwq
        // forked from kjunichi's "2011-08-02 2nd" http://jsdo.it/kjunichi/ch4s
        window.onload = () => {
            const Cross = (v1, v2) => {
                var vx = v1.y * v2.z - v1.z * v2.y;
                var vy = v1.z * v2.x - v1.x * v2.z;
                var vz = v1.x * v2.y - v1.y * v2.x;

                return new THREE.Vector3(vx, vy, vz);
            }

            // calculate Roman surface by u,v parameter.
            const TorusSurface = (u, v) => {
                var a = 1 / 3;
                var c = 1;
                var x = Math.cos(u) * (Math.cos(v) * a + c);
                var y = Math.sin(v) * a;
                var z = Math.sin(u) * (Math.cos(v) * a + c);
                //document.write(x +"," + y + ","+z +"\n");
                return new THREE.Vector3(x, y, z);
            }

            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(400, 400);
            document.body.appendChild(renderer.domElement);

            const scene = new THREE.Scene();

            const camera = new THREE.Camera(
                75,     // Field of view
                400 / 400,  // Aspect ratio
                0.02,     // Near
                1000       // Far
            );
            camera.position.set(0, 5, 5.5);
            scene.addLight(new THREE.AmbientLight(0x101020));

            light1 = new THREE.PointLight(0xff0040, 1, 50);

            scene.addLight(light1);
            const directionalLight = new THREE.DirectionalLight(0xff0000);
            directionalLight.position.x = 0;
            directionalLight.position.y = 0;
            directionalLight.position.z = 1;
            directionalLight.position.normalize();
            scene.addLight(directionalLight);
            const directionalLight2 = new THREE.DirectionalLight(0x00ff00);
            directionalLight2.position.x = 1;
            directionalLight2.position.y = 0;
            directionalLight2.position.z = 0;
            directionalLight2.position.normalize();
            scene.addLight(directionalLight2);
            const directionalLight3 = new THREE.DirectionalLight(0x0000ff);
            directionalLight3.position.x = 0;
            directionalLight3.position.y = 1;
            directionalLight3.position.z = 0;
            directionalLight3.position.normalize();
            scene.addLight(directionalLight3);

            const ustep = 0.1;
            const vstep = 0.1;

            geom = new THREE.Geometry();
            let pCount = 0;
            geom = new THREE.Geometry();
            for (v = 0; v <= Math.PI * 2; v += vstep) {
                for (u = 0; u <= 2 * Math.PI; u += ustep) {
                    v1 = TorusSurface(u, v);
                    v2 = TorusSurface(u + ustep, v);
                    v3 = TorusSurface(u + ustep, v + vstep);
                    v4 = TorusSurface(u, v + vstep);

                    geom.vertices.push(new THREE.Vertex(v1));
                    geom.vertices.push(new THREE.Vertex(v2));
                    geom.vertices.push(new THREE.Vertex(v3));
                    geom.vertices.push(new THREE.Vertex(v4));

                    var nvx1 = v1.x - v2.x;
                    var nvy1 = v1.y - v2.y;
                    var nvz1 = v1.z - v2.z;

                    var nvx2 = v4.x - v2.x;
                    var nvy2 = v4.y - v2.y;
                    var nvz2 = v4.z - v2.z;

                    const faceVertical = Cross(
                        new THREE.Vector3(nvx1, nvy1, nvz1),
                        new THREE.Vector3(nvx2, nvy2, nvz2)
                    );

                    const length = Math.sqrt((faceVertical.x * faceVertical.x
                        + faceVertical.y * faceVertical.y
                        + faceVertical.z * faceVertical.z));

                    const faceNormal = new THREE.Vector3(-faceVertical.x / length, -faceVertical.y / length, -faceVertical.z / length);



                    const face1 = new THREE.Face3(pCount, pCount + 2, pCount + 1);
                    face1.normal = faceNormal;
                    geom.faces.push(face1);
                    
                    const face2 = new THREE.Face3(pCount, pCount + 3, pCount + 2);
                    face2.normal = faceNormal;
                    geom.faces.push(face2);

                    pCount = pCount + 4;


                }
            }
            //geom.computeFaceNormals();
            material = new THREE.MeshLambertMaterial({ color: 0xaaaaaa, shading: THREE.FlatShading });
            //material=new THREE.MeshBasicMaterial( { color:0x0afaaf, vertexColors:false, shading: THREE.FlatShading } );

            object = new THREE.Mesh(geom, material);
            object.overdraw = true;
            object.doubleSided = true;
            object.flipSided = true;
            //object.matrixAutoUpdate=false;
            scene.addChild(object);
    
            const render = () => {
                var a = 1 / 2;
                var c = 1;
                var time = new Date().getTime() * 0.001;

                camera.position.set(1.1 * Math.cos(time), 0.34 * Math.sin(time / 10), 1.1 * Math.sin(time));
                camera.target.position.set(1.0 * Math.cos(time + 0.5), 0, 1.0 * Math.sin(time + 0.5));
                //camera.target.position.set(0, 0.1, 0);
                renderer.render(scene, camera);
            }

            const animate = () => {
                requestAnimationFrame(animate);
                render();
            }
            animate();
        }
    </script>
</body>

</html>